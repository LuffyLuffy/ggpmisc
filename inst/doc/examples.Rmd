---
title: "`ggpmisc` `r packageVersion('ggpmisc')`<br>Additional examples"
author: "Pedro J. Aphalo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Additional Examples}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, echo=FALSE}
library(knitr)
opts_chunk$set(fig.path = 'figure/pos-', fig.align = 'center', fig.show = 'hold',
               fig.width = 7, fig.height = 4)
options(warnPartialMatchArgs = FALSE)
```

## Preliminaries

```{r}
library(ggplot2)
library(ggpmisc)
library(xts)
library(lubridate)
```

## `try_data_frame()`

### Time series

Several different formats for storing time series data are used in R. Here we use in the examples objects of class `ts` but several other classes are supported as `try.xts()` is used internally. The first example is a quarterly series.

```{r}
class(austres)
austres.df <- try_data_frame(austres)
class(austres.df)
lapply(austres.df, "class")
head(austres.df, 4)
```

The next chunk demonstrates that numeric times are expressed as decimal years in the returned data frame.

```{r}
austres.df <- try_data_frame(austres, as.numeric = TRUE)
lapply(austres.df, "class")
head(austres.df, 4)
```

This second example is for a series of yearly values.

```{r}
class(lynx)
lynx.df <- try_data_frame(lynx)
class(lynx.df)
lapply(lynx.df, "class")
head(lynx.df, 3)
```

Above there is a small rounding error of 1 s for these old dates. We can correct this by rounding to year.

```{r}
lynx.df <- try_data_frame(lynx, "year")
head(lynx.df, 3)
```

In addition we can convert the POSIXct values into numeric values in calendar years plus a decimal fraction.

```{r}
lynx_n.df <- try_data_frame(lynx, "year", as.numeric = TRUE)
lapply(lynx_n.df, "class")
head(lynx_n.df, 3)
```

### Other classes

`try_data_frame()` attempts to handle gracefully objects that are not time series.

```{r}
try_data_frame(1:5)
```

```{r}
try_data_frame(letters[1:5])
```

```{r}
try_data_frame(factor(letters[1:5]))
```

```{r}
try_data_frame(list(x = rep(1,5), y = 1:5))
```

```{r}
try_data_frame(data.frame(x = rep(1,5), y = 1:5))
```

```{r}
try_data_frame(matrix(1:10, ncol = 2))
```

## `stat_peaks()` and `stat_valleys()`

Using POSIXct for `time` and the default formatting of labels.

```{r}
ggplot(lynx.df, aes(time, V.lynx)) + geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", vjust = -0.5) +
  ylim(-100, 7300)
```

Using numeric values for `time` and the default formatting of labels.

```{r}
ggplot(lynx_n.df, aes(time, V.lynx)) + geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", vjust = -0.5) +
  ylim(-100, 7300)
```

Using POSIXct for `time` but supplying a format string. In addition marking both peaks and valleys.

```{r}
ggplot(lynx.df, aes(time, V.lynx)) + geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", vjust = -0.5, x.label.fmt = "%Y") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "text", colour = "blue", vjust = 1.5, x.label.fmt = "%Y") +
  ylim(-100, 7300)
```

Using numeric for `time` but supplying a format string. In addition marking both peaks and valleys.

```{r}
ggplot(lynx_n.df, aes(time, V.lynx)) + geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", vjust = -0.5, x.label.fmt = "%4.0f") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "text", colour = "blue", vjust = 1.5, x.label.fmt = "%4.0f") +
  ylim(-100, 7300)
```

Rotating the labels.

```{r}
ggplot(lynx.df, aes(time, V.lynx)) + geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", angle = 66,
             hjust = -0.1, x.label.fmt = "%Y") +
  ylim(NA, 7800)
```

Using `geom_rug` for the peaks and valleys.

```{r}
ggplot(lynx.df, aes(time, V.lynx)) + geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "rug", colour = "red") +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "rug", colour = "blue")
```

## `stat_poly_eq()`

We generate some artificial data.

```{r}
set.seed(4321)
# generate artificial data
x <- 1:100
y <- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data <- data.frame(x, 
                      y, 
                      group = c("A", "B"), 
                      y2 = y * c(0.5,2),
                      block = c("a", "a", "b", "b"))
```

First one example using defaults.

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(formula = formula, parse = TRUE)
```

`stat_poly_eq()` makes available three different labels in the returned data frame. One of these is used by default, but `aes()` can be used to select a different one. 

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..adj.rr.label..), formula = formula, 
               parse = TRUE)
```

BIC and AIC labels are also returned.

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..AIC.label..), 
               formula = formula, 
               parse = TRUE)
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), formula = formula, 
               parse = TRUE)
```

Within `aes()` it is possible to _compute_ new labels based on those returned plus "arbitrary" text. The supplied labels are meant to be _parsed_ into expressions, so any text added should be valid for a string that will be parsed.

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label =  paste(..eq.label.., ..adj.rr.label.., sep = "~~~~")),
               formula = formula, parse = TRUE)
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = paste("atop(", ..AIC.label.., ",", ..BIC.label.., ")", sep = "")), 
               formula = formula, 
               parse = TRUE)
```

Two examples of removing and changing the _lhs_ and/or _rhs_ of the equation.

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = FALSE,
               formula = formula, parse = TRUE)
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(hat(y))~`=`~",
               formula = formula, parse = TRUE)
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  labs(x = expression(italic(z)), y = expression(italic(h)) ) + 
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "italic(h)~`=`~",
               eq.x.rhs = "~italic(z)",
               formula = formula, parse = TRUE)
```

As any valid R expression can be used, Greek letters are also supported, as well as the inclusion in the label of variable transformations used in the model formula.

```{r}
formula <- y ~ poly(x, 2, raw = TRUE)
ggplot(my.data, aes(x, log10(y + 1e6))) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               eq.with.lhs = "plain(log)[10](italic(y)+10^6)~`=`~",
               formula = formula, parse = TRUE)
```

A couple of additional examples of polynomials of different orders, and specified in different ways.

Higher order polynomial.

```{r}
formula <- y ~ poly(x, 5, raw = TRUE)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), formula = formula, parse = TRUE)
```

Intercept forced to zero.

```{r}
formula <- y ~ x + I(x^2) + I(x^3) - 1
ggplot(my.data, aes(x, y)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), formula = formula, 
               parse = TRUE)
```

We give below several examples to demonstrate how other components of the `ggplot` object affect the behaviour of this statistic.

Facets work as expected either with fixed or free scales. Although bellow we had to adjust the size of the font used for the equation. In addition to we manually position the equation label by supplying coordinates.

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), size = rel(3),
               formula = formula, parse = TRUE,
               label.x = 0, label.y = 2e6) +
  facet_wrap(~group)
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..), size = rel(3),
               formula = formula, parse = TRUE) +
  facet_wrap(~group, scales = "free_y")
```

Grouping, in this example using the colour aesthetic also works as expected. We can use justification and supply an absolute location for the equation.

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE,
               label.x = 0, label.y = c(1.8e6, 2e6)) +
  theme_bw()
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..eq.label..),
               formula = formula, parse = TRUE,
               label.x = 0, label.y = 2e6,
               vjust = c(1.2, 0)) +
  theme_bw()
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, colour = group, fill = block)) +
  geom_point(shape = 21, size = rel(3)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..rr.label..), size = rel(3),
               geom = "label", alpha = 0.2,
               formula = formula, parse = TRUE,
               label.x = 0, label.y = c(5e5, 5e5, 2e6, 2e6),
               vjust = c(1.2,0,1.2,0)) +
  facet_wrap(~group, scales = "free_y") +
  theme_bw()
```

```{r}
formula <- y ~ poly(x, 3, raw = TRUE)
ggplot(my.data, aes(x, y2, fill = block)) +
  geom_point(shape = 21, size = rel(3)) +
  geom_smooth(method = "lm", formula = formula) +
  stat_poly_eq(aes(label = ..rr.label..), size = rel(3),
               geom = "label", alpha = 0.33,
               formula = formula, parse = TRUE,
               label.x = 0,
               vjust = c(1.2,0,1.2,0)) +
  facet_wrap(~group, scales = "free_y") +
  theme_bw()
```

## Debugging ggplots

These stats are very simple and print a summary of their `data` input to the
console. In addition they also return a data frame containing labels suitable
for plotting as with geom "text" or geom "label". However, starting from 
version 0.2.7 of the package the default geom is "null". The values are listed
to the console at the time when the `ggplot` object is printed.

As shown here, no other _geom_ or _stat_ is required, however in the remaining
examples we include `geom_point()` to make the data on the plot visible.

```{r}
ggplot(my.data, aes(x, y)) + stat_debug_group()
```
 
In the absence of facets or groups we get just get the summary from one data 
frame.

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + stat_debug_group()
```

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + stat_debug_panel()
```

In the case of grouping then one data frame is summarized for each group
in the ggplot object.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  stat_debug_group()
```

Without facets, we still have only one panel.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  stat_debug_panel()
```

The data are similar, except for the column named after the aesthetic, for the aesthetics used for grouping.

```{r}
ggplot(my.data, aes(x, y, shape = group)) + geom_point() + 
  stat_debug_group()
```

If we use as _geom_ `"label"` or `"text"` a _debug_ summary is added
to the plot itself, we can use other arguments valid for the _geom_ used,
in this case `vjust`.

```{r}
ggplot(my.data, aes(x, y, shape = group)) + geom_point() + 
  stat_debug_group(geom = "label", vjust = c(-0.5,1.5))
```

The summary function can be a user defined one, which allows lots of flexibility.

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + 
  stat_debug_group(summary.fun = summary)
```

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + 
  stat_debug_group(summary.fun = head)
```

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + 
  stat_debug_group(summary.fun = nrow)
```

The default.

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + 
  stat_debug_group(summary.fun = dplyr::as_data_frame)
```

```{r}
ggplot(my.data, aes(x, y)) + geom_point() + 
  stat_debug_group(summary.fun = head, summary.fun.args = list(n = 3))
```

This next chunk showing how to print the whole data frame is not run as its output is more than 100 lines long as the data set contains 100 observations.

```{r, eval=FALSE}
ggplot(my.data, aes(x, y)) + geom_point() + 
  stat_debug_group(summary.fun = function(x) {x})
```

With grouping, for each _group_ the `compute_group()` function is called with a subset of the data.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  stat_debug_group(summary.fun = head, summary.fun.args = list(n = 3))
```

In this example with grouping and facets, within each _panel_ the `compute_group()` function is called for each group, in total four times.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  stat_debug_group(summary.fun = nrow) +
  facet_wrap(~block)
```

With facets, for each _panel_ the `compute_panel()` function is called with a subset of the data that is not split by groups. For our example, it is called twice.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  stat_debug_panel(summary.fun = nrow) +
  facet_wrap(~block)
```

Finally we show how `geom_debug()` can be used. First to print to the console the data as passed to geoms.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  geom_debug(summary.fun = head)
```

And also to print to the console the data returned by a stat. 

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_point() + 
  stat_peaks(span = NULL,
             geom = "debug", 
             summary.fun = function(x) {x}, 
             summary.fun.args = list())
```

The package also defines a "null" geom, which is used as default by the _debug_
_stats_ described above.

```{r}
ggplot(my.data, aes(x, y, colour = group)) + geom_null()
```
